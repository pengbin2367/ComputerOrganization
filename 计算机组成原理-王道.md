# 第1章 计算机系统概述

> #### 考纲内容：
>
> - 计算机系统层次结构
>   - 计算机系统的基本组成
>   - 计算机硬件的基本组成
>   - 计算机软件和硬件的关系
>   - 计算机系统的工作原理：“存储程序”方式、高级语言程序与机器语言程序的转换、程序和指令的执行过程
> - 计算机性能指标
>   - 吞吐量、响应时间、CPU时钟周期、主频、CPI、CPU执行时间
>   - MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS

## 1.1 计算机发展历程

### 1.1.1 计算机硬件的发展

#### 1. 计算机的四代变化

```mermaid
graph LR;
	a[电子管时代] --> b[晶体管时代];
	b --> c[中小规模集成电路时代];
	c --> d[超大规模集成电路时代];
```

#### 2. 计算机元件的更新换代

- 摩尔定律
- 半导体存储器的发展
- 微处理器的发展

### 1.1.2 计算机软件的发展

## 1.2 计算机系统层次结构

### 1.2.1 计算机系统组成

硬件系统和软件系统共同构成了一个完整的计算机系统

### 1.2.2 计算机硬件

#### 1. 冯诺依曼机基本思想

- 采用“存储程序”的工作方式
- 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成
- 指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机可以区分
- 指令和数据均用二进制代码表示。指令由操作码和地址码组成

> “存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无需人为干预，计算机会自动逐条执行指令，直至程序结束

#### 2. 计算机的功能部件

##### a> 输入设备

##### b> 输出设备

##### c> 存储器

- 主存储器（内存储器），CPU能够直接访问，工作方式是按存储单元的地址进行存取，基本组成如图所示：

  ![image-20230220224929642](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230220224929642.png)

  

- 辅助存储器（外存储器）

> 存储体存放二进制信息，地址寄存器（MAR）存放访存信息，经过地址译码后找到所选的存储单元。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号
>
> MAR用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10^ = 1024个存储单元，记为1K。MAR长度与PC长度相等
>
> MDR的位数和存储字长相等，一般为字节的2次幂的整数倍
>
> MAR与MDR虽然是存储器的一部分，但在现代计算机中却是存在于CPU中的，另外，高速缓存（Cache）也是在CPU中

##### d> 运算器

运算器核心是算术逻辑单元（Arithmetic and Logical Unit，ALU）。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前三个寄存器是必须的

运算器内还有程序状态寄存器（PSW），也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无进位或借位、结果是否为负等

##### e> 控制器

控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成。

一般将运算器和控制器集成到同一芯片上，称为中央处理器。CPU和主存储器共同构成主机，而除主机外的其他硬件装置统称为外部设备，简称外设

![image-20230226201855952](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230226201855952.png)

### 1.2.3 计算机软件

#### 1. 系统软件和应用软件

#### 2. 三个级别的语言

机器语言、汇编语言和高级语言

计算机无法之间理解和执行高级语言程序，需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序：

- 汇编程序（汇编器）。将汇编语言程序翻译成机器语言
- 解释程序（解释器）。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行
- 编译程序（编译器）。将高级语言程序翻译成汇编语言或机器语言程序

#### 3. 软件和硬件的逻辑功能等价性

### 1.2.4 计算机系统的层次结构

![image-20230226205515420](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230226205515420.png)

层次之间的关系紧密，下层是上层的基础，上层是下层的扩展

软件和硬件之间的界面就是指令集体系结构（ISA），ISA定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，以及所处理的的操作数存放的地址空间和操作数类型。

### 1.2.5 计算机系统的工作原理

#### 1. “存储程序”工作方式

![image-20230226210731906](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230226210731906.png)

#### 2. 从源程序到可执行文件

![image-20230226215211762](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230226215211762.png)

预处理阶段 -----> 编译阶段 -----> 汇编阶段 -----> 链接阶段

#### 3. 程序执行过程的描述

#### 4. 指令执行过程的描述

以取数指令为例，其信息流程如下：

1. 取指令：PC ---> MAR ---> M ---> MDR ---> IR
2. 分析指令：OP(IR) ---> CU
3. 执行指令：Ad(IR) ---> MAR ---> M ---> MDR ---> ACC

## 1.3 计算机的性能指标

### 1.3.1 计算机的主要性能指标

#### 1. 字长

指计算机进行一次整数运算所能处理的二进制数据的位数

#### 2. 数据通路带宽

数据总线一次所能并行传送信息的位数

> 各个子系统通过数据总线连接形成的数据传送路径称为数据通路

#### 3. 主存容量

主存储器所能存储信息的最大容量

#### 4. 运算速度

##### a> 吞吐量和响应时间

吞吐量指系统在单位时间内处理请求的数量，系统吞吐量主要取决于主存的存取周期

##### b> 主频和CPU时钟周期

CPU时钟周期，主频的倒数，是CPU中最小的时间单位

主频（CPU时钟频率），机器内部主时钟的频率

##### c> CPI（Cycle Per Instruction）

执行一条指令所需的时钟周期数

##### d> CPU执行时间

$$
CPU执行时间 = \frac {CPU时钟周期数} {主频} = \frac {指令条数 \times CPI} {主频}
$$

##### e> MIPS（Million Instructions Per Second），每秒执行多少百万条指令

$$
MIPS = \frac {指令条数}{执行时间 \times 10^6} = \frac {主频} {CPI \times 10^6}
$$

##### f> MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和ZFLOPS

#### 5. 基准程序

### 1.3.2 几个专业术语

#### 1. 系列机

具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列

#### 2. 兼容

指软件和硬件的通用性

#### 3. 软件可移植性

指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性

#### 4. 固件

将程序固化在ROM中组成的部件

# 第2章 数据的表示和运算

> #### 考纲内容：
>
> - 数制与编码
>   - 进位计数制及其相互转换，定点数的编码表示
> - 运算方法和运算电路
>   - 基本运算部件：加法器，算术逻辑单元（ALU）
>   - 加/减运算：补码加/减运算器，标志位的生成
>   - 乘/除运算：乘/除法运算的基本原理，乘法运算和除法电路的基本结构
> - 整数的表示和运算
>   - 无符号整数的表示和运算，带符号整数的表示和运算
> - 浮点数的表示和运算
>   - 浮点数的表示：IEEE754标准，浮点数的加/减运算

## 2.1 数制与编码

### 2.1.1 进位计数制及其相互转换

#### 1. 进位计数法

#### 2. 不同进制数之间的相互转换

> 在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确的用二进制表示
>
> 十进制转换为任意进制数采用除基取余法和乘基取整法

#### 3. 真值和机器数

真值是机器数所代表的实际值

### 2.1.2 BCD码

- 8421码。若相加之和大于等于10,则要加6修正，并向高位进位
- 余3码。在8421码的基础上加3
- 2421码。特点是大于或等于5的4位二进制数中最高位为1，小于5的最高位为0，如5 ---> 1011

### 2.1.3 定点数的编码表示

在现代计算机中，通常用定点补码整数表示整数，定点原码小数表示浮点数的尾数部分，移码表示浮点数的阶码部分

#### 1. 机器数的定点表示

- 定点小数
- 定点整数

#### 2. 原码、补码、反码、移码

- 原码表示法

  原码表示的优点是与真值的对应关系简单、直观，与真值的转换简单，并且用原码实现乘除运算比较简单。缺点是，0的表示不唯一，更重要的是原码加减运算比较复杂

- 补码表示法

- 反码表示法

  0的表示不唯一，表示范围比补码少一个最小负数。反码在计算机中很少使用，通常作为数码变换的中间表示形式

- 移码表示法

  移码常用来表示浮点数的阶码。它只能表示整数

  移码中零的表示唯一，一个真值的移码和补码仅差一个符号位（补码符号位取反就得到了移码）

  移码全0时，对应的真值最小值-2^n^，移码全1时，对应真值的最大值2^n^ - 1

  移码保持了数据原有的大小顺序，移码大真值就大

原码、补码、反码、移码：

1. 原码、补码、反码符号位相同，正数的机器码相同
2. 原码、反码的表示在数轴上对称，二者都存在+0和-0两个零
3. 补码、移码的表示在数轴上不对称，零的表示唯一，他们比原码、反码多表示一个数
4. 整数的补码、移码的符号位相反，数值位相同
5. 负数的反码、补码末位相差1
6. 原码很容易判断大小。而负数的反码、补码很难直接判断大小（对于负数，数值部分越大，绝对值越小，真值越大）

### 2.1.4 整数的表示

#### 1. 无符号整数的表示

#### 2. 带符号整数的表示

计算机中的带符号整数都用补码表示，相比其他三码具有以下优势：

1. 与原码和反码相比，0的补码表示唯一
2. 与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算
3. 与原码和反码相比，补码比原码和反码多表示一个最小负数

## 2.2 运算方法和运算电路

### 2.2.1 基本运算部件

在计算机中，运算器由算术逻辑单元（Arithmetic Logic Unit，ALU）、移位器、状态寄存器和通用寄存器等组成。运算器的基本功能包括加减乘除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU的核心部件就是加法器

#### 1. 一位全加器

全加器（FA）是最基本的加法单元

#### 2. 串行进位加法器

#### 3. 并行进位加法器

#### 4. 带标志加法器

#### 5. 算术逻辑单元（ALU）

### 2.2.2 定点数的移位运算

#### 1. 算术移位

![image-20230301101912723](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230301101912723.png)

#### 2. 逻辑移位

逻辑移位将操作数视为无符号数

移位规则：左移，丢高位，低位添0；右移，丢低位，高位添0

#### 3. 循环移位

### 2.2.3 定点数的加减运算

#### 1.  补码的加减法运算

- 按二进制运算规则运算，逢二进一
- 加法直接相加，减法则将被减数与减数的机器负数相加
- 符号为与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出
- 最终运算结果的高位丢弃，保留n + 1位，运算结果亦为补码

#### 2. 补码加减运算电路

#### 3. 溢出判别方法

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，补码定点数加减运算溢出判断的方法有3种：

- 采用一位符号位

- 采用双符号位

  也称模4补码，运算结果的两个符号位相同，表示未溢出；不同表示溢出，此时最高位符号位代表真正的符号

- 采用一位符号位根据数据位的进位情况判断溢出 

#### 4. 原码的加减法运算

### 2.2.4 定点数的乘除运算

#### 1. 定点数的乘法运算

- 原码一位乘法。符号位与数值位分开求
- 无符号数乘法运算电路
- 补码一位乘法（Booth算法）
- 补码乘法运算电路

#### 2. 定点数的除法运算

- 符号扩展
- 原码除法运算（不恢复余数法）
- 补码除法运算（加减交替法）
- 除法运算电路

### 2.2.5 C语言中的整数类型及类型转换

#### 1. 有符号数和无符号数的转换

强制类型转换的结果保持位值不变，仅改变了解释这些位的方式

#### 2. 不同字长整数之间的转换

当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位直接赋值

短字长向长字长转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。原数字是无符号整数，则进行零扩展，否则进行符号扩展

### 2.2.6 数据的存储和排列

#### 1. 数据的“大端方式”和“小端方式”存储

大端方式按从最高有效字节到最低有效字节的顺序存储数据

#### 2. 数据按“边界对齐”方式存储

边界对齐方式相对边界不对齐方式是一种空间换时间的思想

## 2.3 浮点数的表示与运算

### 2.3.1 浮点数的表示

#### 1. 浮点数的表示格式

![image-20230301162639578](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230301162639578.png)

阶码的值反映浮点数的小数点的实际位置

阶码的位数反映浮点数的表示范围

尾数的位数反映浮点数的精度

#### 2. 浮点数的表示范围

上溢趋于无穷，下溢趋于0，数据下溢时，浮点数值趋于零，计算机仅将其当作机器零处理

#### 3. 浮点数的规格化

指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值

#### 4. IEEE754标准

![image-20230301164841150](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%8E%8B%E9%81%93.assets/image-20230301164841150.png)

#### 5. 定点、浮点表示的区别

- 数值范围。若字长相同，则浮点表示法所能表示的数值范围远大于定点表示法
- 精度。对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了
- 数的运算。浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂
- 溢出问题。定点运算中，超出数的表示范围则溢出；浮点运算超出数的表示范围不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出

### 2.3.2 浮点数的加减运算

浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数加减运算分为以下几步：

#### 1. 对阶

对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移一位，阶加一，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度

#### 2. 尾数求和

将对阶后的尾数按定点数加减运算规则运算

#### 3. 规格化

运算后的尾数不一定是规格化的

- 左规一次相当于乘2，右规一次相当于除2
- 需要右规时，只需进行一次

#### 4. 舍入

在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将低位移出的两位保留下来，参与中间过程的运算，最后将运算结果进行舍入，还原成IEEE754格式

常见舍入方法有：

- 0舍1入法，类似四舍五入
- 恒置1法
- 截断法

#### 5. 溢出判断

#### 6. C语言中的浮点数类型

C语言中的float和double类型分别对应于IEEE754单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数

在C程序中等式的赋值和判断中会出现强制类型转换，以char --> int --> long --> double和float --> double最为常见，从前到后范围和精度都从小到大，转换过程没有损失

1. int --> float,虽然不会发生溢出，但float尾数连隐藏位共24位，当int型数第24～31位非零时，无法精确转换成24位浮点数的尾数，需进行舍入处理，影响精度
2. int或float转换为double时，因double有效位数更多，因此能保留精确值
3. double转换为float时，可能溢出，而且尾数有效位数变少，因此高精度数转换时会发生舍入
4. float或double转换为int时，因int没有小数部分，数据会向0方向截断，发生舍入。另外，可能溢出